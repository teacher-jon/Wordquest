<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WordCraft: Solid Earth</title>
    <style>
        :root {
            --bg-color: #1a1a2e;
            --ui-border: #5d4037;
        }
        body {
            background-color: var(--bg-color);
            color: #2c3e50;
            font-family: 'Verdana', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0; padding: 10px; height: 100vh; overflow: hidden;
            user-select: none;
        }
        #game-frame {
            position: relative;
            border: 8px solid var(--ui-border);
            border-radius: 4px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.8);
            line-height: 0;
            background: #000;
        }
        canvas { display: block; image-rendering: pixelated; }
        
        #overlay-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; align-items: center; justify-content: center;
        }
        .popup {
            pointer-events: auto;
            background: #fff;
            border: 4px solid var(--ui-border);
            padding: 20px; border-radius: 8px;
            text-align: center; max-width: 600px;
            display: none; box-shadow: 5px 5px 10px rgba(0,0,0,0.5);
            max-height: 90%; overflow-y: auto;
        }
        .popup.active { display: block; }
        
        #screen-inv {
            width: 600px; height: 450px;
            background-image: url('assets/bg.png');
            background-size: cover;
            color: #3e2723;
        }

        .forge-tabs { display: flex; border-bottom: 2px solid #5d4037; margin-bottom: 15px; }
        .tab { flex: 1; padding: 10px; cursor: pointer; font-weight: bold; background: rgba(255,255,255,0.3); }
        .tab.active { background: rgba(255,255,255,0.6); border-bottom: 3px solid #3e2723; }
        
        .crafting-grid { display: flex; justify-content: center; align-items: center; gap: 10px; margin: 15px 0; }
        .craft-slot { 
            width: 60px; height: 60px; border: 2px dashed #5d4037;
            display: flex; align-items: center; justify-content: center;
            font-weight: bold; background: rgba(0,0,0,0.05); cursor: pointer;
        }
        .inv-grid { 
            display: flex; flex-wrap: wrap; gap: 5px; justify-content: center; 
            max-height: 220px; overflow-y: auto; padding: 5px;
        }
        .word-chip { 
            background: #fff; border: 1px solid #5d4037; padding: 4px 8px; 
            border-radius: 12px; cursor: pointer; font-size: 11px; font-weight: bold;
            box-shadow: 1px 1px 2px rgba(0,0,0,0.2);
        }
        .word-chip:hover { transform: scale(1.05); background: #ffe0b2; }
        
        .chip-pre { background-color: #e3f2fd; }
        .chip-suf { background-color: #f3e5f5; }
        .chip-inf { background-color: #fff3e0; }

        button {
            background: #27ae60; border: none; color: white; padding: 10px 20px;
            font-size: 16px; font-weight: bold; cursor: pointer; border-radius: 4px; margin: 5px;
        }
        .toggle-container { margin: 15px 0; display: flex; align-items: center; justify-content: center; gap: 10px; }
        .toggle-btn { background: #ccc; border-radius: 20px; width: 40px; height: 20px; position: relative; cursor: pointer; }
        .toggle-btn.on { background: #27ae60; }
        .toggle-btn.on::after { left: 22px; }
        .toggle-btn::after { content:''; position: absolute; left: 2px; top: 2px; width: 16px; height: 16px; background: white; border-radius: 50%; transition: 0.3s; }

        .tag-1 { color: #5d4037; border-left: 4px solid #795548; }
        .tag-2 { color: #455a64; border-left: 4px solid #78909c; }
        .tag-3 { color: #f57f17; border-left: 4px solid #ffd54f; }
        
        h2 { border-bottom: 2px solid #eee; padding-bottom: 5px; margin-bottom: 10px; color: #d35400; }
        p { line-height: 1.5; margin-bottom: 15px; }
    </style>
</head>
<body>
    <div id="game-frame">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div id="loading" style="position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); color:white;">
            Solidifying Ground...
        </div>

        <div id="overlay-layer">
            <div id="screen-start" class="popup active">
                <h1 style="color:#c0392b; margin-top:0;">WordCraft: Solid Earth</h1>
                
                <div style="text-align: left; background: #f9f9f9; padding: 10px; border-radius: 4px; font-size: 14px; max-height: 200px; overflow-y: auto;">
                    <h2>üìú Updates</h2>
                    <p><b>Solid Ground:</b> No more gaps between blocks!</p>
                    <p><b>Fortress Mode:</b> Build walls/doors to stop enemies.</p>
                    
                    <h2>‚öîÔ∏è Controls</h2>
                    <p>
                    ‚Ä¢ <b>Arrows:</b> Move/Aim<br>
                    ‚Ä¢ <b>Space:</b> Mine / Attack<br>
                    ‚Ä¢ <b>'I' Key:</b> Inventory<br>
                    ‚Ä¢ <b>'B' Key:</b> Place Active Block<br>
                    </p>
                </div>

                <div class="toggle-container" onclick="toggleMonsters()">
                    <span>Letter Bugs:</span>
                    <div id="monster-toggle" class="toggle-btn on"></div>
                    <span id="monster-status">ON</span>
                </div>

                <button onclick="setGameState('playing')">Enter World</button>
            </div>
            
            <div id="screen-death" class="popup">
                <h1 style="color:red;">Scrambled!</h1>
                <p>The Letter Bugs scrambled your words.</p>
                <button onclick="location.reload()">Respawn</button>
            </div>

            <div id="screen-inv" class="popup">
                <div class="forge-tabs">
                    <div class="tab active" onclick="switchTab('word')">Word Forge</div>
                    <div class="tab" onclick="switchTab('craft')">Tool Bench</div>
                </div>
                
                <div id="tab-word">
                    <div class="crafting-grid">
                        <div id="slot-pre" class="craft-slot" onclick="clearSlot('pre')">[Pre]</div> +
                        <div id="slot-root" class="craft-slot" onclick="clearSlot('root')">[ROOT]</div> +
                        <div id="slot-suf" class="craft-slot" onclick="clearSlot('suf')">[Suf]</div>
                        <button onclick="forgeWord()">üî®</button>
                    </div>
                    <div id="forge-msg" style="height:20px; font-weight:bold; color:#d84315; font-size:12px;"></div>
                    <div style="display:flex; gap:10px; text-align:left; margin-top:10px;">
                        <div style="flex:1;">
                            <small><b>COLLECTED ROOTS</b></small>
                            <div id="list-roots" class="inv-grid"></div>
                        </div>
                        <div style="flex:1;">
                            <small><b>AFFIXES</b></small>
                            <div class="inv-grid">
                                <span class="word-chip chip-pre" onclick="setSlot('pre','un')">un-</span>
                                <span class="word-chip chip-pre" onclick="setSlot('pre','re')">re-</span>
                                <span class="word-chip chip-pre" onclick="setSlot('pre','dis')">dis-</span>
                                <span class="word-chip chip-pre" onclick="setSlot('pre','pre')">pre-</span>
                                <span class="word-chip chip-pre" onclick="setSlot('pre','uni')">uni-</span>
                                <span class="word-chip chip-pre" onclick="setSlot('pre','bi')">bi-</span>
                                <span class="word-chip chip-pre" onclick="setSlot('pre','tri')">tri-</span>
                                <span class="word-chip chip-pre" onclick="setSlot('pre','sub')">sub-</span>
                                <span class="word-chip chip-inf" onclick="setSlot('suf','s')">-s</span>
                                <span class="word-chip chip-inf" onclick="setSlot('suf','es')">-es</span>
                                <span class="word-chip chip-inf" onclick="setSlot('suf','ed')">-ed</span>
                                <span class="word-chip chip-inf" onclick="setSlot('suf','ing')">-ing</span>
                                <span class="word-chip chip-inf" onclick="setSlot('suf','er')">-er</span>
                                <span class="word-chip chip-inf" onclick="setSlot('suf','est')">-est</span>
                                <span class="word-chip chip-suf" onclick="setSlot('suf','ly')">-ly</span>
                                <span class="word-chip chip-suf" onclick="setSlot('suf','less')">-less</span>
                                <span class="word-chip chip-suf" onclick="setSlot('suf','ful')">-ful</span>
                                <span class="word-chip chip-suf" onclick="setSlot('suf','ness')">-ness</span>
                                <span class="word-chip chip-suf" onclick="setSlot('suf','ment')">-ment</span>
                                <span class="word-chip chip-suf" onclick="setSlot('suf','able')">-able</span>
                                <span class="word-chip chip-suf" onclick="setSlot('suf','ible')">-ible</span>
                                <span class="word-chip chip-suf" onclick="setSlot('suf','ish')">-ish</span>
                                <span class="word-chip chip-suf" onclick="setSlot('suf','y')">-y</span>
                                <span class="word-chip chip-suf" onclick="setSlot('suf','ture')">-ture</span>
                                <span class="word-chip chip-suf" onclick="setSlot('suf','tion')">-tion</span>
                            </div>
                        </div>
                    </div>
                </div>

                <div id="tab-craft" style="display:none;">
                    <h3>Survival Gear</h3>
                    <div style="font-size:12px; color:#555; margin-bottom:5px;">Click to Select Active Block for Placing ('B')</div>
                    <div class="inv-grid" style="flex-direction:column;">
                        <div class="word-chip" onclick="craft('quill')" style="padding:10px;"><b>Golden Quill</b> (Weapon) - 10 üíé</div>
                        <div class="word-chip" onclick="craft('potion')" style="padding:10px;"><b>Health Potion</b> (+1 ‚ù§Ô∏è) - 5 üíé</div>
                        
                        <div class="word-chip" id="btn-wall" onclick="setActiveBlock(9, 'Wall')" style="padding:10px; border-left:5px solid #5d4037;">
                            <b>Dirt Wall</b> (x<span id="qty-9">5</span>) - 1 üíé
                        </div>
                        <div class="word-chip" id="btn-wood" onclick="setActiveBlock(4, 'Wood')" style="padding:10px; border-left:5px solid #d35400;">
                            <b>Wood Planks</b> (x<span id="qty-4">0</span>) - 2 üíé
                        </div>
                        <div class="word-chip" id="btn-brick" onclick="setActiveBlock(5, 'Brick')" style="padding:10px; border-left:5px solid #c0392b;">
                            <b>Stone Brick</b> (x<span id="qty-5">0</span>) - 2 üíé
                        </div>
                        <div class="word-chip" id="btn-door" onclick="setActiveBlock(8, 'Door')" style="padding:10px; border-left:5px solid #f1c40f;">
                            <b>Magic Door</b> (x<span id="qty-8">0</span>) - 3 üíé
                        </div>
                    </div>
                </div>
                <button onclick="setGameState('playing')" style="margin-top:10px; background:#5d4037;">Close Book</button>
            </div>
        </div>
    </div>
    <div style="color:#aaa; font-size:12px; margin-top:5px;">ARROWS: Move/Aim | SPACE: Mine | 'I': Inventory | 'B': Place <span id="hud-block-name">Wall</span></div>

<script>
    // --- ASSET LOADER ---
    const assets = { tiles: new Image(), chars: new Image(), ui: new Image() };
    const processedAssets = { tiles: null, chars: null, ui: null };
    let loadedCount = 0; const requiredImages = 3;

    function onAssetLoad() { 
        loadedCount++; 
        if(loadedCount === requiredImages) processAssets(); 
    }

    function removeWhiteBackground(img) {
        const c = document.createElement('canvas');
        const cx = c.getContext('2d');
        c.width = img.width; c.height = img.height;
        cx.drawImage(img, 0, 0);
        let imgData = cx.getImageData(0, 0, c.width, c.height);
        let data = imgData.data;
        for(let i = 0; i < data.length; i += 4) {
            let r = data[i], g = data[i+1], b = data[i+2];
            if(r > 240 && g > 240 && b > 240) data[i+3] = 0;
        }
        cx.putImageData(imgData, 0, 0);
        return c;
    }

    function processAssets() {
        processedAssets.tiles = removeWhiteBackground(assets.tiles);
        processedAssets.chars = removeWhiteBackground(assets.chars);
        processedAssets.ui = removeWhiteBackground(assets.ui);
        document.getElementById('loading').style.display = 'none';
        initGame();
    }

    assets.tiles.src = 'assets/tiles.png'; assets.tiles.onload = onAssetLoad;
    assets.chars.src = 'assets/chars.png'; assets.chars.onload = onAssetLoad;
    assets.ui.src = 'assets/ui.png';       assets.ui.onload = onAssetLoad;

    // --- GAME CONFIG ---
    const TILE_SIZE = 40; 
    const COLS = 200; const ROWS = 60;  
    const CANVAS_W = 800; const CANVAS_H = 600;
    const canvas = document.getElementById('gameCanvas'); const ctx = canvas.getContext('2d');
    canvas.width = CANVAS_W; canvas.height = CANVAS_H;

    const DAY_LENGTH = 3600; const NIGHT_START = DAY_LENGTH / 2;
    let gameTick = 0; let monstersEnabled = true;

    let camera = { x: 0, y: 0 };
    let keys = {}; 

    // --- UFLI ROOT DATA ---
    const LAYER_ROOTS = {
        1: ["play", "help", "jump", "walk", "look", "ask", "wish", "hope", "make", "use", "like", "ride", "smile", "time", "run", "hop", "sit", "win", "cut", "shop", "swim", "sad"],
        2: ["happy", "funny", "penny", "baby", "carry", "cry", "try", "cycle", "angle", "view", "port", "form", "cover", "fair", "kind", "joy", "care", "fear", "pain", "dark"],
        3: ["struct", "ject", "rupt", "phon", "graph", "scope", "meter", "bio", "chron", "vis", "aud", "terr", "fract", "pic", "mix"]
    };

    const WORD_CACHE = {};

    let state = 'start'; let grid = []; let enemies = []; let particles = []; let animTick = 0;
    
    // Block IDs: 9=DirtWall, 4=Wood, 5=Brick, 8=Door
    let player = { 
        x:20, y:10, hp:3, maxHp:3, fragments:0, roots:[], hasQuill:false, 
        invinc:0, facingLeft:false,
        blocks: { 9: 5, 4: 0, 5: 0, 8: 0 },
        activeBlock: 9,
        activeBlockName: "Dirt Wall"
    };
    let forge = { pre:null, root:null, suf:null };

    function initGame() {
        grid = [];
        for(let r=0; r<ROWS; r++){
            let row = [];
            for(let c=0; c<COLS; c++){
                let surface = 10 + Math.floor(Math.sin(c * 0.1) * 3); 
                if(r < surface) row.push(0); 
                else if(r < surface + 5) row.push(1); 
                else if(r < surface + 20) row.push(2); 
                else row.push(3); 
            }
            grid.push(row);
        }
        
        let groundY = 0;
        while(groundY < ROWS && grid[groundY][20] === 0) groundY++;
        player.y = groundY - 1; 
        
        requestAnimationFrame(loop);
    }

    function loop() {
        if(state === 'playing') update();
        draw();
        requestAnimationFrame(loop);
    }

    function update() {
        animTick++; gameTick++;
        if(player.invinc > 0) player.invinc--;
        let timeOfDay = gameTick % DAY_LENGTH;
        let isNight = timeOfDay > NIGHT_START;

        // Camera
        let targetCamX = (player.x * TILE_SIZE) - (CANVAS_W / 2);
        let targetCamY = (player.y * TILE_SIZE) - (CANVAS_H / 2);
        camera.x = Math.max(0, Math.min(targetCamX, (COLS * TILE_SIZE) - CANVAS_W));
        camera.y = Math.max(0, Math.min(targetCamY, (ROWS * TILE_SIZE) - CANVAS_H));

        // Spawning
        if(monstersEnabled && isNight && animTick % 200 === 0 && enemies.length < 5) {
            let spawnX = player.x + (Math.random() > 0.5 ? 12 : -12);
            let spawnY = player.y - 5 + Math.floor(Math.random()*10);
            if(spawnX > 0 && spawnX < COLS && spawnY > 0 && spawnY < ROWS && grid[spawnY][spawnX] === 0) {
                 enemies.push({ x:spawnX, y:spawnY, type:Math.random()>.5?'bat':'slime', hp:2, speed:20 });
            }
        }
        
        // Enemy Logic
        enemies.forEach((en,i) => {
            if(Math.abs(en.x - player.x) < 25) {
                if(animTick % en.speed === 0) {
                    let nextX = en.x; let nextY = en.y;
                    if(en.x < player.x) nextX++; else if(en.x > player.x) nextX--;
                    else if(en.y < player.y) nextY++; else if(en.y > player.y) nextY--;
                    if(grid[nextY][nextX] === 0) { en.x = nextX; en.y = nextY; }
                }
                if(en.x === player.x && en.y === player.y) hurtPlayer();
            }
        });
        if(!monstersEnabled && enemies.length > 0) enemies = [];
        for(let i=particles.length-1; i>=0; i--) {
            particles[i].life--; particles[i].y-=0.5; if(particles[i].life<=0) particles.splice(i,1);
        }
    }

    // --- CONTROLS ---
    document.addEventListener('keydown', e => {
        keys[e.key] = true; 
        if(state !== 'playing') { if(e.key==='i'||e.key==='I') setGameState('playing'); return; }
        
        let dx=0, dy=0;
        if(e.key==='ArrowLeft') { dx=-1; player.facingLeft=true; }
        if(e.key==='ArrowRight') { dx=1; player.facingLeft=false; }
        if(e.key==='ArrowUp') dy=-1; 
        if(e.key==='ArrowDown') dy=1;

        if(dx!==0 || dy!==0) {
            let nx = player.x+dx, ny = player.y+dy;
            if(nx>=0 && nx<COLS && ny>=0 && ny<ROWS) {
                let t = grid[ny][nx]; 
                if(t===0 || t===8) { player.x=nx; player.y=ny; }
            }
        }

        if(e.key===' ') action();
        if(e.key==='i'||e.key==='I') setGameState('inventory');
        if(e.key==='b'||e.key==='B') placeBlock();
    });

    document.addEventListener('keyup', e => { keys[e.key] = false; });

    function action() {
        let hit=false;
        if(player.hasQuill) {
            enemies.forEach((en,i)=>{
                if(Math.abs(en.x-player.x)+Math.abs(en.y-player.y)<=1) {
                    en.hp--; hit=true; addPart(en.x,en.y,"üí•"); if(en.hp<=0) { enemies.splice(i,1); player.fragments+=3; }
                }
            });
        }
        if(hit) return;

        let tx = player.x; let ty = player.y;
        if(keys['ArrowUp']) ty -= 1; else if(keys['ArrowDown']) ty += 1;
        else if(keys['ArrowLeft']) tx -= 1; else if(keys['ArrowRight']) tx += 1;
        else { tx += (player.facingLeft ? -1 : 1); if(grid[ty][tx] === 0) ty += 1; }

        if(tx>=0 && tx<COLS && ty>=0 && ty<ROWS) {
            let t = grid[ty][tx];
            if(t>=1 && t<=5 || t===9) { // Mine
                grid[ty][tx]=0; player.fragments++; addPart(tx,ty,"‚ú®");
                if(Math.random()>0.7 && t<=3) {
                    let list = LAYER_ROOTS[t]||["root"];
                    player.roots.push({word:list[Math.floor(Math.random()*list.length)], type:t}); addPart(player.x,player.y-1,"üìú");
                }
            }
        }
    }
    
    function placeBlock() {
        let id = player.activeBlock;
        if(player.blocks[id] > 0) {
            if(grid[player.y][player.x] === 0) {
                grid[player.y][player.x] = id;
                player.blocks[id]--;
                updateInvCounts();
                addPart(player.x, player.y, "üî®");
            }
        }
    }

    function hurtPlayer() { if(player.invinc>0) return; player.hp--; player.invinc=30; addPart(player.x,player.y,"üíî"); if(player.hp<=0) setGameState('death'); }
    function addPart(x,y,c) { particles.push({x:x,y:y,char:c,life:30}); }

    function draw() {
        let timeOfDay = gameTick % DAY_LENGTH;
        let cyclePos = Math.sin((timeOfDay / DAY_LENGTH) * Math.PI);
        let r = Math.floor(135 * cyclePos + 20 * (1-cyclePos));
        let g = Math.floor(206 * cyclePos + 20 * (1-cyclePos));
        let b = Math.floor(235 * cyclePos + 60 * (1-cyclePos));
        ctx.fillStyle = `rgb(${r},${g},${b})`; ctx.fillRect(0,0,CANVAS_W,CANVAS_H); 

        // --- THE "GROUT" FIX ---
        // We crop the source image (Smart Zoom) AND fill behind the tiles (Grout)
        let tW = processedAssets.tiles.width; 
        let tH = processedAssets.tiles.height/5;
        let cropX = tW * 0.20; 
        let cropY = tH * 0.10;
        let drawW = tW - (2*cropX);
        let drawH = tH - (2*cropY);

        let startCol = Math.floor(camera.x / TILE_SIZE);
        let endCol = startCol + (CANVAS_W / TILE_SIZE) + 1;
        let startRow = Math.floor(camera.y / TILE_SIZE);
        let endRow = startRow + (CANVAS_H / TILE_SIZE) + 1;

        ctx.save();
        ctx.translate(-camera.x, -camera.y);

        for(let row=startRow; row<=endRow; row++){
            for(let col=startCol; col<=endCol; col++){
                if(row<0 || row>=ROWS || col<0 || col>=COLS) continue;
                let t = grid[row][col];
                if(t>0) { 
                    let tidx = 0; let tint = null; let baseColor = "#5d4037"; // Default grout color (Dark Brown)
                    
                    if(t<=3) { tidx = t-1; if(t===2) baseColor="#7f8c8d"; if(t===3) baseColor="#ecf0f1"; }
                    else if(t===9) { tidx = 3; }
                    else if(t===4) { tidx = 3; tint = "brown"; }
                    else if(t===5) { tidx = 1; tint = "red"; baseColor="#c0392b"; }
                    else if(t===8) { tidx = 3; tint = "gold"; }

                    // STEP 1: GROUT (Fill background to hide gaps)
                    ctx.fillStyle = baseColor;
                    ctx.fillRect(col*TILE_SIZE, row*TILE_SIZE, TILE_SIZE+1, TILE_SIZE+1);

                    // STEP 2: DRAW IMAGE (With Overlap)
                    ctx.drawImage(processedAssets.tiles, cropX, (tidx*tH)+cropY, drawW, drawH, col*TILE_SIZE, row*TILE_SIZE, TILE_SIZE+1, TILE_SIZE+1); 
                    
                    if(tint) {
                        ctx.fillStyle = tint === "brown" ? "rgba(100,50,0,0.5)" : tint === "red" ? "rgba(100,0,0,0.3)" : "rgba(255,215,0,0.3)";
                        ctx.fillRect(col*TILE_SIZE, row*TILE_SIZE, TILE_SIZE, TILE_SIZE);
                        if(t===8) { ctx.fillStyle="black"; ctx.fillRect((col*TILE_SIZE)+15, (row*TILE_SIZE)+20, 5, 5); } 
                    }
                }
            }
        }

        let cW = processedAssets.chars.width/3; let cH = processedAssets.chars.height/3;
        drawChar(0, 0, Math.floor(animTick/20)%2, player.x, player.y, player.facingLeft);
        enemies.forEach(en => {
            if(en.x >= startCol && en.x <= endCol) {
                drawChar((en.type==='bat')?1:2, Math.floor(animTick/10)%3, 0, en.x, en.y, false);
            }
        });
        ctx.font="20px Arial"; ctx.fillStyle="white"; 
        particles.forEach(p => ctx.fillText(p.char, p.x*TILE_SIZE, p.y*TILE_SIZE));
        ctx.restore(); 

        drawHUD(timeOfDay);
    }

    function drawChar(row, col, animOffset, x, y, flip) {
        let cW = processedAssets.chars.width/3; let cH = processedAssets.chars.height/3;
        ctx.save();
        if(flip) { ctx.translate((x*TILE_SIZE)+TILE_SIZE, y*TILE_SIZE); ctx.scale(-1, 1); ctx.drawImage(processedAssets.chars, (col+animOffset)*cW, row*cH, cW, cH, 0, 0, TILE_SIZE, TILE_SIZE); }
        else { ctx.drawImage(processedAssets.chars, (col+animOffset)*cW, row*cH, cW, cH, x*TILE_SIZE, y*TILE_SIZE, TILE_SIZE, TILE_SIZE); }
        ctx.restore();
    }
    function drawHUD(time) {
        let uW = processedAssets.ui.width/2; let uH = processedAssets.ui.height/2;
        for(let i=0; i<player.maxHp; i++) if(i<player.hp) ctx.drawImage(processedAssets.ui, 0, 0, uW, uH, 10+(i*35), 10, 30, 30);
        ctx.drawImage(processedAssets.ui, uW, 0, uW, uH, 150, 10, 30, 30); 
        ctx.fillStyle = "white"; ctx.font = "bold 20px Verdana";
        ctx.fillText(player.fragments, 185, 33);
        if(player.hasQuill) ctx.drawImage(processedAssets.ui, 0, uH, uW, uH, 250, 10, 30, 30); else ctx.fillText("üî®", 250, 33);
        let isNight = time > NIGHT_START; ctx.fillText(isNight ? "üåô Night" : "‚òÄÔ∏è Day", CANVAS_W-100, 33);
    }

    // --- UI FUNCTIONS ---
    function setGameState(s) {
        state=s; document.querySelectorAll('.popup').forEach(e=>e.classList.remove('active'));
        if(s==='start') document.getElementById('screen-start').classList.add('active');
        if(s==='death') document.getElementById('screen-death').classList.add('active');
        if(s==='inventory') { document.getElementById('screen-inv').classList.add('active'); renderRoots(); updateInvCounts(); }
    }
    function toggleMonsters() {
        monstersEnabled = !monstersEnabled;
        let btn = document.getElementById('monster-toggle');
        let txt = document.getElementById('monster-status');
        if(monstersEnabled) { btn.classList.add('on'); txt.innerText = "ON"; } else { btn.classList.remove('on'); txt.innerText = "OFF"; }
    }
    function switchTab(t) {
        document.getElementById('tab-word').style.display = t==='word'?'block':'none';
        document.getElementById('tab-craft').style.display = t==='craft'?'block':'none';
        document.querySelectorAll('.tab').forEach(e=>e.classList.remove('active')); event.target.classList.add('active');
    }
    function renderRoots() {
        let d = document.getElementById('list-roots'); d.innerHTML="";
        player.roots.forEach(r => { let s = document.createElement('div'); s.className=`word-chip tag-${r.type}`; s.innerText=r.word; s.onclick=()=>setSlot('root',r.word); d.appendChild(s); });
        if(player.roots.length===0) d.innerText="No roots found.";
    }
    function setActiveBlock(id, name) {
        player.activeBlock = id;
        player.activeBlockName = name;
        document.getElementById('hud-block-name').innerText = name;
        alert("Selected: " + name + ". Press 'B' to place.");
    }
    function updateInvCounts() {
        document.getElementById('qty-9').innerText = player.blocks[9];
        document.getElementById('qty-4').innerText = player.blocks[4];
        document.getElementById('qty-5').innerText = player.blocks[5];
        document.getElementById('qty-8').innerText = player.blocks[8];
    }
    function setSlot(t,v) { forge[t]=v; document.getElementById(`slot-${t}`).innerText=v; }
    function clearSlot(t) { forge[t]=null; document.getElementById(`slot-${t}`).innerText=`[${t}]`; }
    function craft(i) {
        if(i==='quill' && player.fragments>=10) { player.fragments-=10; player.hasQuill=true; alert("Crafted Quill!"); }
        else if(i==='potion' && player.fragments>=5 && player.hp<3) { player.fragments-=5; player.hp++; alert("Healed!"); }
        else if(i==='wall' && player.fragments>=1) { player.fragments-=1; player.blocks[9]+=5; updateInvCounts(); }
        else if(i==='wood' && player.fragments>=2) { player.fragments-=2; player.blocks[4]+=5; updateInvCounts(); }
        else if(i==='brick' && player.fragments>=2) { player.fragments-=2; player.blocks[5]+=5; updateInvCounts(); }
        else if(i==='door' && player.fragments>=3) { player.fragments-=3; player.blocks[8]+=1; updateInvCounts(); }
        else if(player.fragments < 2) alert("Not enough fragments!");
    }
    async function forgeWord() {
        if(!forge.root) return;
        let m = document.getElementById('forge-msg');
        m.innerHTML = "Checking ancient texts..."; 
        let base = forge.root; let pre = forge.pre || ""; let suf = forge.suf || "";
        let rawWord = (pre + base + suf).toLowerCase();
        let correctedWord = rawWord;
        
        if (suf.length > 0) {
            if (base.endsWith('e') && isVowel(suf[0])) correctedWord = pre + base.slice(0, -1) + suf;
            else if (isCVC(base) && isVowel(suf[0])) correctedWord = pre + base + base[base.length-1] + suf;
            else if (base.endsWith('y') && !isVowel(base[base.length-2]) && suf[0] !== 'i') correctedWord = pre + base.slice(0, -1) + "i" + suf;
        }

        let definition = await checkValidity(correctedWord);
        if (definition) {
            m.innerHTML = `<span style="color:green">‚ú® ${correctedWord.toUpperCase()}</span>: ${definition}`;
            if (rawWord !== correctedWord) m.innerHTML += `<br><small style="color:#555">(Spelling rule: ${rawWord} ‚ûî ${correctedWord})</small>`;
            player.fragments += 5;
        } else {
            if (rawWord !== correctedWord) {
                let rawDef = await checkValidity(rawWord);
                if (rawDef) { m.innerHTML = `<span style="color:green">‚ú® ${rawWord.toUpperCase()}</span>: ${rawDef}`; return; }
            }
            m.innerHTML = `‚ùå "${correctedWord}" is not in the dictionary.`;
        }
    }
    function isVowel(char) { return ['a','e','i','o','u','y'].includes(char); }
    function isCVC(word) {
        if(word.length < 3) return false;
        let last = word[word.length-1]; let middle = word[word.length-2]; let first = word[word.length-3];
        return !isVowel(last) && isVowel(middle) && !isVowel(first);
    }
    async function checkValidity(word) {
        if (WORD_CACHE[word]) return WORD_CACHE[word];
        try {
            const response = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${word}`);
            if (!response.ok) return null;
            const data = await response.json();
            let def = data[0].meanings[0].definitions[0].definition;
            WORD_CACHE[word] = def; return def;
        } catch (e) { return null; }
    }
</script>
</body>
</html>
